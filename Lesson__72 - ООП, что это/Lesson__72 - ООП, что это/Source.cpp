#include <iostream>

using namespace std;

/*То что было ДО - процедурное программирование(процедурный подход). Три кита ООП: инкапсуляция, наследование,
полиморфизм. ООП возникло для того, чтобы программисту(человеку) было проще работать с кодом. 
В программном коде реализация объектов осуществляется с помощью классов и структур

Рассмотрим программный объект на примере объекта из реального мира - кофемолка. Конкретная кофемолка, которая
находится у меня на столе - это объект. Конкретная кофемолка есть экземпляр класса кофемолки(определенного шаблона, 
который имеет определенную форму, размеры, остроту лезвий - все это свойства объекта, нашей кофемолки)

В ООП у объектов тоже есть свойства, которые созданы по шаблону, который где-то описан. У объекта есть какая-то функция, 
например, молоть кофе. В ООП такие функции называются методы(методы, с помощью которых вы можете взаимодействовать с объектом, т.е с кофемолкой)

Принципы ООП
Инкапсуляция - принцип независимости данных в объектно ориентированном программировании. Т.е. один программист, 
который разрабатывает класс(включающий свойства объекта) какого-то объекта может скрыть некие его свойства, некий функционал, 
который нужен для функционирования этого объекта, от другого пользователя. И оставить пользователю какие-то внешние элементы управления, 
с помощью которого другой пользователь может работать с таким объектом(пользователь - другой программист, который берет класс, который
разработал первый программист и использует его в своей программе)
Другими словами, возвращаясь к кофемолке, мы можем только насыпать в нее зерна, нажать кнопочку перемолоть и достать зерна. 
Мы не можем влиять на скорость вращения шпинделя(который вращает лопости), на угол наклона лезвий и тд. Т.е. есть некий скрытый функционал, 
с которым мы не можем ничего сделать. У нас есть только собственный интерфейс, с которым мы можем работать - кнопка вкллючить и выключить. 

Наследование - процесс, с помощью которого один объект может наследовать свойства и методы другого объекта и
дополнять их к своему функционалу. К примеру мы хотим описать класс кофе-машины и создать объект кофе-машины.
В таком случае класс для перемалывания кофе мы можем наследовать от нашей кофемолки для нашей кофе-машины(есть уже
реализованный механизм, не нужно заново писать этот функционал). В результате кофе-машина получает метод молоть кофе
и остальные свойства кофемолки

Полиморфизм - возможность объекта вести себя по-разному, в зависимости от ситуации и реагировать на какое-то одно действие
каким-то специфическим образом именно конкретно для этого класса объектов.
Пример: кофемолки бывают разные(электрические, механические), в одном случае нажимаешь на кнопку, в другом случае
крутишь ручку - реализация разная. Но функция(метод, который мы вызовем у объекта, будет один и тот же - молоть кофе).

Еще примеры в паре с автомобилем: 
Инкапсуляция: у машины есть метод(функция) ехать, тормозить, заправиться. Но у вас нет необходимости знать как это все работает, 
устроено - для вас этот функционал скрыт.

Наследование: к примеру у нас есть класс "транспортное средство", которое тоже может ехать, останавливаться, его нужно заправлять.
Это абстрактный класс, у нас нету реализации какого-то конкретного транспортного средства, но мы можем от него унаследовать: 
--легковой автомобиль, который тоже может ехатЬ, останавливаться и заправляется, к примеру, бензином.
--Можем унаследовать от этого класса какую-то фуру, которая гораздо мощнее - у нее отличается топливо, но те же самые методы, 
те же самые функции, с помощью которых мы будет взаимодействовать с этим объектом - ехать, останавливаться, заправляться.
--электромобиль и тд.

Полиморфизм: методы все одинаковые(ехать, останавливаться, заправляться), но выполняться на двигателе внутреннего сгорания и 
электрическом двигателе они будут по-разному - реализация от нас скрыта, но интерфейс один и тот же.


*/

void main()
{

}