#include <iostream>

using namespace std;

/*Деструктор класса - специальная функция, которая срабатывает при разрушении объекта класса.
Сами вызвать мы его не можем, он вызывается при уничтожении объекта класса

Деструктор в классе только один. Нужен для того, чтобы красиво освобождать ресурсы, выделенные под объект класса. 
Деструкторов с параметрами не бывает
Синтаксис: ~class-name() {}

Когда вызывается деструктор: допустим создал объект класса в какой-то фукнции. Компилятор доходит до строки создания
объекта, идет ниже. Когда компилятор полностью проходит функцию и выходит из области ее видимости(последняя строчка, 
либо return), в этот момент, после return, вызывается деструктор класса(сам)

Все поля в классе по умолчанию - private. Это если явно не указать public или protected

Деструкторы класса вызываются в порядке, противоположном вызову конструктора класса. Т.е. у нас три объекта, 
которые мы инициализируем по очереди. Удаляться(вызов деструктора) они будут начиная с 3, потом второй, потом первый.
Т.е. чем ниже в коде находится объект, тем быстрее он удалится


*/

//class Maslo
//{
//	int data;		//Это приватное поле
//
//public:
//
//	Maslo(int order)
//	{
//		data = order;
//		cout << "Объект: " << data << ", Вызвался конструктор" << endl;
//	}
//
//	~Maslo()
//	{
//		cout << "Объект: " << data << ", Вызвался деструктор" << endl;			//Деструкторов с параметрами нету, поэтому
//	}																			//чтобы передать значение order деструктору, 
//};		
//																		//присваиваем его полю data
//void Zhop()
//{
//	cout << "Функция zhop начала работу" << endl;
//	Maslo margarita(4);
//	cout << "Функция zhop закончила работу" << endl;
//}


//Пример с динамическим массивом
class Maslo
{
private:
	int* data;		//Этот динамический массив за пределами класса у нас очистить не получится,
					//т.к. он инициализирован в приватной области. Тут нам и пригодится деструктор
public:

	Maslo(int size)
	{
		data = new int[size];
		cout << "Объект: " << data << ", Вызвался конструктор" << endl;
	}

	~Maslo()
	{
		delete[] data;
		cout << "Объект: " << data << ", Вызвался деструктор" << endl;			//Деструкторов с параметрами нету, поэтому
	}																			//чтобы передать значение order деструктору, 
};
//присваиваем его полю data
void Zhop()
{
	cout << "Функция zhop начала работу" << endl;
	Maslo margarita(4);
	cout << "Функция zhop закончила работу" << endl;
}



int main()
{
	setlocale(LC_ALL, "ru");

	//Maslo zolotayaSemechka(1);
	Zhop();						//объект margarita(4) завершится раньше всех, т.к. компилятор дойдет до конца области видимости
	//Maslo oliva(2);				//функции Zhop() раньше всех. Следовательно, деструктор вызовется раньше всех
	//Maslo totalKvarz(3);						
	

	return 0;
}