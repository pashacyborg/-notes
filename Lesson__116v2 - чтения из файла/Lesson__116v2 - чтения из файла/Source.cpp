#include <iostream>
#include <string>
#include <fstream>
#include <windows.h>

using namespace std;

/*ifstrim - input file stream/поток ввода. Нужен для считывания данных из файла(НЕ ДЛЯ ЗАПИСИ В ФАЙЛ)
* Оба потока(ifstream, ofstream) обращаюстя к файлу и могут использовать метод Open. Просто один поток вносит новые данные в файл,
* а другой пиздит уже существующие, что позволяет переиспользовать считанные данные.
* Метод close() освобождает ресурсы, которые мы занимали при работе с конкретным файлом.
*
* ifstream в отличии от ofstream не создает файл. Он либо открывает его, либо нет(если его не существует).
* Поток байт можно считывать не только посимвольно, но и построчно.
*
* Метод get() считывает по одному символу с файла, помещая данный символ в переменную. Если у метода получилось что-то считать,
* он возвращает true, если не получилось, возвращает false.
* Посимвольно считываются в том числе пробелы и символы конца строки.
*
* Построчное считывание.
* Метод get не подходит, используем у объекта типа ifstream метод eof()(end of file). Этот метод вернет TRUE, когда в нашем файле
* больше не останется данных. Если в файле после основных данных имеется пустая строка, eof() посчитает ее за данные и наш цикл
* не остановится, что может привести к ошибке(двойное считывание последнего слова из нашего документа, т.к. переменная с прошлой
* итерации все еще хранит это слово). Поэтому следует каждую итерацию обнулять значение переменной-буфера и следить за тем, чтобы в файле
* не было пустых строк.
* Таким образом, метод eof() считывает хоть и не посимвольно, но пословно.
* Для построчного считывания существует метод getline() - тот, что находится в пространстве имен std(а не метод ifstream).
* Синтаксис: getline(ifstream-object, string-variable); 
* Когда такой метод натыкается на пробел, он его пропускает. Когда на символ конца строки - считывание останавливается.
*
* Недостаток метода getline() у ifstream является формат принимаемых значений. Нужно указывать массив символов(строка, кол-во символов).
* Таким образом нужно создавать статический массив char str[size], точно знать какое количество символов занимает наша строка - геморрой.
*
* Объект типа ifstream нужно использовать с оператором >>, что позволяет считывать данные из файла(cin вводит данные).
* Объект типа ofstream Нужно использовать с оператором <<, что позволяет сохранять данные в файл(cout выводит данные)
*
* При считывании данных из файла, мы помещаем их в какую-то конкретную переменную - полная аналогия с cin. При сохранении данных
* в файл, мы их выводим в текстовый документ, тоже полная аналогия с cout.
*
* По умолчанию оператор >> считывает данные до первого пробела.
* 
* Нерешенная проблема: кириллица считывается корректно только в том случае, если: 
* 1)Тектовый документ в кодировке ANSI
* 2)Если проект не закрыт на ноутбуке. После закрытия проекта программа работать не будет, придется пересоздавать
*/

int main()
{
	//setlocale(LC_ALL, "ru");
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);

	ifstream fin;
	string path = "maslo.txt";
	fin.open(path);

	if (!fin.is_open())
	{
		cout << "Ошибка открытия файла!" << endl;
	}
	else
	{
		cout << "Файл открыт!" << endl;
		cout << "\n\n";

		/*char ch;
		while (fin.get(ch))
		{							case with get()
			cout << ch;
		}*/

		//string str;
		//while (!fin.eof())	//Тут важно отрицание. Если мы его уберем, будет "цикл работает, пока файл пустой"
		//{
		//	str = "";	//Каждый раз затираем нашу переменную во избежание ошибок				
		//	fin >> str;		//Помещаем строку из файла в переменную str
		//	cout << str << endl;												case with eof()
		//}

		string str;
		while (!fin.eof())
		{
			str = "";
			getline(fin, str);			//case with eof() end getline(ifstream_object, string_variable);
			cout << str << endl;
		}

		cout << "\n\n";
	}

	fin.close();



	return 0;
}