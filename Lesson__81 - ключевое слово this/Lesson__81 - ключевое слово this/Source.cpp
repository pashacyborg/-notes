#include <iostream>

using namespace std;

/*Ключевое слово this
Каким образом компилятор знает как вызвать метод Print? Как он понимает, что нужно вызвать данный метод для конкретного
объекта а не для другого? Компилятор знает, что у разных объектов разные адреса в памяти. Когда мы пишем a.print(); - 
компилятор обращается по адресу объекта a, и через этот адрес обращается к методу Print(). Адрес объекта хранит ключевое
слово this - по сути указатель объекта на самого себя(знание объекта того, где он находится в памяти)

Константный указатель this можно использовать только внутри класса.

Синтаксис: this->имя-поля/метода.   Еще раз, this-> - это по сути имя объекта, которое хранит его адрес в памяти

Смотри пример с сеттером, там возникает неоднозначность: компилятор думает, что все x внутри этого метода одинаковые(параметры
функции). Нам нужно явно указать, что один из них - это поле нашего объекта
*/

class Coordinate
{
private:
	int x;
	int y;

public:
	Coordinate()
	{
		cout << "у объекта " << this << " вызвался конструктор класса" << endl;
	}

	Coordinate(int x, int y)
	{
		this->x = x;
		this->y = y;
		cout << "у объекта " << this << " вызвался конструктор класса" << endl;
	}
	
	int GetX()
	{
		return x;
	}

	void SetX(int x, int y)
	{
		/*x = x;		*/	//В таком случае в наше поле х внутри private ничего не запишется
		this->x = x;	//В таком случае все четенько. Мы говорим, что это ПОЛЕ НАШЕГО ОБЪЕКТА, экземпляра класса
		this->y = y;
	}

	void Print()
	{
		cout << "x = " << x  << "\ty = " << y << endl;
		cout << "Выведи x через this, x = " << this->GetX() << endl;			//Получаем значение x с помощью метода Getx
	}
};

int main()
{
	setlocale(LC_ALL, "ru");

	Coordinate pointOne;
	pointOne.SetX(10, 5);			//Передаем в метод SetX параметры для x и y
	pointOne.Print();

	Coordinate pointTwo(228, 1337);			//Передаем нужные параметры в поля при инициализации объекта
	pointTwo.Print();


	return 0;
}