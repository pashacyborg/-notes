#include <iostream>

using namespace std;

/*Когда мы очистили ячейку памяти, на которую указывает указатель, но адрес сохранился, это может привести
к ошибкам, если мы вдруг нечаянно обратимся по этому указателю и нарушим ход другой программы, которая использует эту
память. Если два раза использовать команду delete для указателя, компиллятор выдаст ошибку и программа
поломается. Запись вида pa = 0 и pa = NULL - равнозначны. Это делает наш указатель нулевым, он больше
не хранит адрес ячейки памяти.
Если вызвать повторный delete после очистки адреса в памяти указателя(pa = NULL), то ошибки не возникнет, т.к.
оператор delete не будет там ничего чистить. Поэтому сначала пишется delete, а затем NULL
nullptr - Отдельный тип данных. Дает тот же результат, что и NULL, но штука более надежная(потому что в 
отличии от NULL или 0, nullprt компиллятор никогда не перепутает с интом*/

void main()
{
	int* pa = new int;
	*pa = 10;

	cout << *pa << endl;	
	delete pa;
	cout << pa << endl;		//Все еще можно вывести 
	  
	pa = nullptr;
	cout << pa << endl;		//Выведет одни нули

	//if (pa != nullptr)
	//{
	//	cout << pa << endl;		//Популярная проверка
	//}
}







