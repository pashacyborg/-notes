#include <iostream>

using namespace std;

/*Виртуальный - возможный, условный. 
Виртуальные функции один из основных способов реализации полиморфизма(классы с одними и теми же методами, 
но вести себя будут по-разному). Для того, чтобы в другом классе переопределить одноименный метод(унаследованный), 
надо в родительском классе сделать этот метод виртуальным.

Ключевое слово override существует для дополнительного контроля за виртуальными методами. 
Синтаксис: возвращаемое_значение имя_метода(параметры) override 
Пишется дочерним классам, у которых используется переопределенный родительский метод. В случае ошибки в написании
возвращаемого значения/названия метода/параметров, выдаст ошибку. Также выдаст ошибку при отсутствии слова virtual у базового класса
Если override не писать, программа скомпилируется, это будет совершенно другой метод, но мы об этом знать не будем. 

Указатель на объект базового класса хранит в себе ссылку не только на свой собственный объект, но и на объекты всех наследников 
этого базового класса.

*/

class Gun
{
public:
	virtual void Shooting()
	{
		cout << "BANG!" << endl;
	}
};

class SubmachineGun : public Gun
{
public:
	void Shooting() override
	{
		cout << "BANG! BANG! BANG!" << endl;
	}
};

class Bazooka : public Gun
{
public:
	void Shooting() override
	{
		cout << "BADABUM!" << endl;
	}
};

class Player : public Gun
{
public:
	void Shooting(Gun* gun) 
	{
		gun->Shooting();
	}
};

int main()
{
	setlocale(LC_ALL, "ru");

	Gun gun;
	SubmachineGun Sgun;
	Bazooka bazooka;

	//Gun* weapon = &gun;	//В указатель на базовый класс положили ссылку на объект базового класса. Вызвался метод базового класса
	//weapon->Shooting();	//При работе с указателями обращение к методам через стрелку

	//Gun* weapon = &Sgun;	//А тут положили ссылку на объект класса-наследника. Вызывается метод класса-наследника
	//weapon->Shooting();		//Если у базового класса убрать свойство virtual, вызовается метод базового класса и полиморфизм работать не будет

	Player player;
	player.Shooting(&bazooka);

	return 0;
}