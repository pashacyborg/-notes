#include <iostream>

using namespace std;

/*Оператор присваивания можно использовать и с пользовательскими типами данных(объектами)
Если у нас есть два объекта а и б, то мы не можем просто написать a = b, т.к. у этих двух объектов будут дублироваться адреса
ячеек памяти(у двух объектов адреса будут идентичны)

Для того, чтобы такой проблемы не возникало, нам нужно выполнить перегрузку оператора = . Когда мы перегружаем операторы, 
для этого есть специальное ключевое слово operator, затем сам оператор =, и круглые скобки для параметров: 
возвр-знач operator = () { }
Если в параметрах написано const MyClass& other) - это означает, что мы принимает в качестве параметра константную ссылку
на объект, но не делаем локальную копию, как в случае с конструктором класса.

По сути наша перезгрузка - это функция. Можно написать развернуто a.operator=(b), можно сокращенно: a = b;

Разница при реализации с конструктором копирования: конструктором копирования мы пользовались при инициализации нашего объекта, 
т.е. в нем еще не было полей, динамически выделенной памяти и тд. Для перерузки оператора = мы должны подразумевать, что у нашего
объекта, который мы хотим изменить на другой объект, уже есть поля и/или динамически выделенная память. 
Поэтому для объекта this Необходимо очистить поля с динамической памятью, чтобы не было утечки памяти. 
В нешем случае конструктор класса всегда выделяет динамическую память под новый объект, поэтому ошибки стирания и так пустой
памяти у нас не будет, однако по дефолту лучше устанавливать динамическое поле в nullptr(если реализация конструктора класса
не подразумевает изначальной инициализации), а затем в перегрузке оператора = , перед освобождением динамической памяти, 
делать проверку на nullptr(во избежания ошибок)

Внимание: очищать динамическую память надо у изначального объекта, поэтому при реализации команды delete[] нам нужно явно
указать не только поле, но и объект, у которого мы будем удалять эти данные: delete[] this->dataField;
После того, как мы очистили поля для динамической памяти, мы можем смело копировать релаизацию из конструктора копирования
для этих динамических полей. Что касается поля Size, то его можно переопределить еще до очистки dataField, поскольку 
поле Size не является динамическим. Его можно просто переопределить.

Задача данной перегрузки - в ситуации, когда объекты разные, присвоить ЗНАЧЕНИЕ одного объекта, значению другого объекта, а не
один объект другому объекту(как это реализованно в операторе = по умолчанию)

Если мы попробуем провернуть для наших объектов запись типа a = b = c, то столкнемся со сложностями. 
Порядок действий в такой операции:
1)b = c
2)a = b

В первом действии мы передаем константной ссылкой наш объект с, а внутри перегруженного оператора лепим объект b по образу
и подобию с. Вот мы его слепили. Теперь надо вернуть слепленное значение в изначальную функцию main, чтобы выполнить действие 2. Возвращать значение 
надо по ссылке на получившийся объект b внутри перегруженного оператора в место вызова оператора(как я понял).

Второй действие: передаем из функции main объект b по ссылке в перегруженный оператор по старой схеме

Возвращать надо объект this(тот объект, в который мы присваиваем значения другого объкта) с оператором разыменования *
*/

class Coordinate
{
public:
	int* dataField;								

	Coordinate(int size)
	{
		this->Size = size;
		this->dataField = new int[size];

		for (int i = 0; i < size; i++)
		{
			dataField[i] = i;
			cout << dataField[i];
		}
		cout << endl;

		cout << this << "\t- У этого объекта вызвался конструктор класса" << endl;
	}

	Coordinate(const Coordinate& other)
	{
		this->Size = other.Size;		 								
		this->dataField = new int[other.Size];		

		for (int i = 0; i < other.Size; i++)
		{
			this->dataField[i] = other.dataField[i];
			cout << this->dataField[i];
		}
		cout << endl;
		cout << this << "\t- У этого объекта вызвался Конструктор Копирования" << endl;
	}

	Coordinate& operator = (const Coordinate& other)
	{
		this->Size = other.Size;

		if (this->dataField != nullptr)
		{
			delete[] this->dataField;
		}

		this->dataField = new int[Size];			//Нам не нужно вечно писать other.Size, т.к мы уже переопределили наш
													//локальный Size
		for (int i = 0; i < Size; i++)
		{
			this->dataField[i] = other.dataField[i];
		}
		cout << this << "\t- У этого объекта вызвался оператор = " << endl;

		return *this;			//обязательно писать с оператором разыменования
	}

	~Coordinate()
	{
		cout << this << "\t- У этого объекта вызвался ДЕСТРУКТОР класса" << endl;
		delete[] dataField;	
	}

private:
	int Size;
};


int main()
{
	setlocale(LC_ALL, "ru");
																//case2
	Coordinate a(5);
	Coordinate b(10);
	Coordinate c(4);
	//a.operator=(b);		//Эта и нижняя запись эквивалентны
	//a = b;	
	a = b = c;
	//a.operator=(b.operator=(c));			//То же самое, что и a = b = c. Нам нужно возвращаемое значение от b.operator=(c)

																//case1
	//Coordinate c(228);
	//Coordinate d = c;			//Вызовется конструктор копирования, т.к. мы используем оператор присваивания в момент 
								//инициализации(наш объект еще пустой)
	//Coordinate d(c);			//Такая запись эквивалентна предыдущей. Вызовется конструктор копирования


	return 0;
}