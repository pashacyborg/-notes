#include <iostream>

using namespace std;

/*Конструктор копирования отвечает за копирование объектов
Запись типа void maslo(MyClass value) показывает, что наша функция принимает параметры по значению. В С++ передача параметров
по значению реализуется по умолчанию, если тока мы явно не укажем ссылку/указатель и тд. 
При передаче параметра по значению внутри нашей функции создается новая переменная того типа, которого мы принимаем параметром и 
данные, из переменной, которую мы передаем в функцию, копируются в переменную внутри функции. В функции мы работаем с локальной
копией переменной, которую мы передали. Поэтому все изменения, которые будут происходить с нашей локальной копией, никак не 
повлияют на нашу изначальную переменную, которую мы передавали в качестве аргумента.

Аргументы фукнции - значения, которые передаются при вызове функции в круглых скобках: Maslo(5, 6)
Параметр функции - локальные переменные, которые задаются при объявлении функции(int a, int b).

Объект класса можно передавать в качестве аргумента.
В классе есть встроенный конструктор копирования, который делает побитовое копирование(абсолютно идентичное). 
return копирует данные и вызывает конструктор копирования? 

Конструктор копирования, скопировав динамический массив, копирует и адрес памяти этого динамического массива

Конструктор копироваия - специальный конструктор в языке программирования, применяемый для создания нового объекта как копии
уже существующего. Такой конструктор принимает как минимум один аргумент: ссылку на копируемый объект
Синтаксис: class-name(const class-name &)

Конструктор класса - специальный метод класса(функция), вызываемый при создании объекта(для инициализации этого объекта). 

Деструктор класса - специальный метод класса, служащий для деинициализации объекта(освобождения ресурсов, которые он занимает)

Запись типа this->data = data эквивалентна записи(или почти эквивалентна) objectName.data = data
Указатели - переменные, которые хранят адреса памяти. Их можно разыменовывать с опомщью оператора разыменования * для
извлечения значений, хранимых по адресу памяти. Разыменование указателя, значением которого является мусор, приведет к ошибке

this - указатель, который указывает на адрес объекта класса

Конструктор копирования – конструктор, реализуемый по умолчанию, и вызываемый при копировании объекта класса(передача параметром переменной типа класс).
Его особенность в том, что он делает абсолютно идентичную копию объекта побитово.
Это может создать проблему в том случае, когда в описании класса мы реализуем динамический массив. В таком случае, 
при копировании экземпляра класса, динамический массив тоже скопируется, а также и адрес его указателя. 
Иначе говоря, два указателя будут хранить один и тот же адрес, и когда мы попытаемся реализовать оператор delete[] в деструкторе,
он попытается дважды очистить одно и то же место в оперативной памяти, что и вызовет ошибку.

Синтаксис:

class Human
{
public:
	   Human(const Human &other)	//передача параметром объекта типа класс, разумеется, по ссылке
	   {

	   }
};

Еще раз: конструктор копирования полностью скопирует экземпляр класса со всеми полями и адресами. Деструктор, сработав дважды
(т.к. у нас два объекта), очистит динамическую память по одному и тому же адресу. Вернее в первый раз у него это получится,
а во второй - вызовется ошибка.

Для того, чтобы такой ситуации избежать, нам нужно явно прописать конструктор копирования.
По дефолту конструктор копирования работает вот так: this->data = other.data - это топорный метод

Для того, чтобы узнать, будет ли вызываться конструктор класса или нет, мы можем открыть отладчик и посмотреть
Конструктор копирования позволяет реализовать копирование объектов таким образом, которым нам надо, а не так как по умолчанию. 
И избежать ошибок при работе с динамическими объектами
*/

//class Coordinate
//{
//public:
//	int dataField;
//
//	Coordinate(int dataField)
//	{
//		this->dataField = dataField;
//		cout << this << "\t- У этого объекта вызвался конструктор класса" << endl;		//for case 1,2
//	}
//
//	~Coordinate()
//	{
//		cout << this << "\t- У этого объекта вызвался ДЕСТРУКТОР класса" << endl;
//	}
//};

class Coordinate
{
public:
	int* dataField;								//for case 3

	Coordinate(int size)
	{
		this->Size = size;
		this->dataField = new int[size];

		for (int i = 0; i < size; i++)
		{
			dataField[i] = i;
			cout << dataField[i];
		}
		cout << endl;

		cout << this << "\t- У этого объекта вызвался конструктор класса" << endl;
	}

	Coordinate(const Coordinate& other)
	{
		//this->dataField = other.dataField;			//Дефолтный механизм конструктора копирования. Приведет к ошибке в деструкторе
		this->Size = other.Size;		//Копируем в поле Size объекта pointFour(наша новая копия) значение поля Size объекта other(pointThree) 									
		this->dataField = new int[other.Size];		//Выделяем новую память под копию объекта

		for (int i = 0; i < other.Size; i++)
		{
			this->dataField[i] = other.dataField[i];
			cout << this->dataField[i];//Поэлементно копируем данные с предыдущего объекта в нашу копию pointFour
		}
		cout << endl;
		cout << this << "\t- У этого объекта вызвался Конструктор Копирования" << endl;
	}

	~Coordinate()
	{
		cout << this << "\t- У этого объекта вызвался ДЕСТРУКТОР класса" << endl;
		delete[] dataField;			//Освобождаем динамическую память, контролируем утечки
	}

private:
	int Size;
};

//void Foo(Coordinate value)			//В этом месте вызывается конструктор копирования, а не конструктор класса	case1
//{
//	cout << "Вызвалась функция Foo" << endl;
//}


//Coordinate Foo_2()		//создание функции, возвращающей значение типа coordinate. т.е. по сути, она возвращает оббъект
//{
//	Coordinate pointtwo(228);
//	return pointtwo;			//В момент return эта функция вызывает конструктор копирования и передает копию объекта pointTwo,
//								//поэтому на месте вызова функции Foo_2 окажется совершенно новый объект(хоть и такой же по значению)
//								//Поэтому вызовется еще один деструктор
//}

int main()
{
	setlocale(LC_ALL, "ru");

	//Coordinate pointOne(10);			//case 1
	//Foo(pointOne);

	//Foo_2();			//case 2
	
	Coordinate pointThree(5);
	Coordinate pointFour(pointThree);			//При передаче pointThree мы можем явно вызвать конструктор копирования, а не только опосредованно
												//В таком случае вызовется один конструктор класса и два деструктора
	return 0;
}