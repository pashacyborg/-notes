#include <iostream>

using namespace std;

/*Абстрактный класс нужен для того, чтобы с помощью указателя на этот класс работать с его наследниками

Класс, имеющий чисто виртуальный деструктор, является абстрактным.
Чтобы такая конструкция работала, нужно вынести определение чисто виртуального деструктора вне класса А   A::~A() {};*/

class A
{
public:
	A()
	{
		cout << "Выделена динамическая память под класс A" << endl;
	}
	virtual ~A() = 0;
};

A::~A() {};

class B : public A
{
public:
	B()
	{
		cout << "Выделена динамическая память под класс B" << endl;
	}
	
	~B() override
	{
		cout << "Динамическая память класса B очищена" << endl;
	}
};

int main()
{
	setlocale(LC_ALL, "ru");

	A* ptra = new B;
	delete ptra;


	return 0;
}